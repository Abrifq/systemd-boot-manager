#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#  zz-update-systemd-boot
#
#  Copyright 2022 Thomas Castleman <contact@draugeros.org>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#
"""Keep systemd-boot up-to-date with installed kernels and new systemd-boot versions"""
from __future__ import print_function
import re
import sys
import os
import shutil
import subprocess
import json
import systemd_boot_manager


class LooseVersion():
    """Version numbering for anarchists and software realists.
    Implements the standard interface for version number classes as
    described above.  A version number consists of a series of numbers,
    separated by either periods or strings of letters.  When comparing
    version numbers, the numeric components will be compared
    numerically, and the alphabetic components lexically.  The following
    are all valid version numbers, in no particular order:

        1.5.1
        1.5.2b2
        161
        3.10a
        8.02
        3.4j
        1996.07.12
        3.2.pl0
        3.1.1.6
        2g6
        11g
        0.960923
        2.2beta29
        1.13++
        5.5.kw
        2.0b1pl0

    In fact, there is no such thing as an invalid version number under
    this scheme; the rules for comparison are simple and predictable,
    but may not always give the results you want (for some definition
    of "want").

    ---

    This class is stolen ("stolen") from the distutils module in Python 3.10 standard library.
    Here, I have manually merged it with it's super class in order to reduce processing time,
    memory usage, and disk space. The super class wasn't being used for anything else anyways.

    We have done this because we rely on this class for sort()-ing kernel images by version, and with
    the deprication of distutils in Python 3.12, we need to find a solution sooner rather than later.

    This prevents further technical debt, reduces dependencies, reduces memory footprint, and allows more
    visibility of this code in case something goes wrong. This is legitamatly the WORST solution for
    something like this I have EVER come up with. But, unless the setuptools module has something
    that will work for this better than what we have here, I see no better solution.
    """

    component_re = re.compile(r'(\d+ | [a-z]+ | \.)', re.VERBOSE)

    def __init__ (self, vstring=None):
        if vstring:
            self.parse(vstring)

    def __repr__ (self):
        return "%s ('%s')" % (self.__class__.__name__, str(self))

    def __eq__(self, other):
        c = self._cmp(other)
        if c is NotImplemented:
            return c
        return c == 0

    def __lt__(self, other):
        c = self._cmp(other)
        if c is NotImplemented:
            return c
        return c < 0

    def __le__(self, other):
        c = self._cmp(other)
        if c is NotImplemented:
            return c
        return c <= 0

    def __gt__(self, other):
        c = self._cmp(other)
        if c is NotImplemented:
            return c
        return c > 0

    def __ge__(self, other):
        c = self._cmp(other)
        if c is NotImplemented:
            return c
        return c >= 0

    def parse (self, vstring):
        # I've given up on thinking I can reconstruct the version string
        # from the parsed tuple -- so I just store the string here for
        # use by __str__
        self.vstring = vstring
        components = [x for x in self.component_re.split(vstring)
                              if x and x != '.']
        for i, obj in enumerate(components):
            try:
                components[i] = int(obj)
            except ValueError:
                pass

        self.version = components

    def __str__ (self):
        return self.vstring

    def __repr__ (self):
        return "LooseVersion ('%s')" % str(self)

    def _cmp (self, other):
        if isinstance(other, str):
            other = LooseVersion(other)

        if self.version == other.version:
            return 0
        if self.version < other.version:
            return -1
        if self.version > other.version:
            return 1


# end class LooseVersion



NEEDED_FILES = ["config", "initrd.img", "System.map", "vmlinuz"]
VERBOSE = False

# Important Dirs/Files
BOOT_DIR = "/boot/"
EFI_DIR = BOOT_DIR + "efi"
SD_LOADER_DIR = EFI_DIR + "/loader"
CLEAN_DIR = SD_LOADER_DIR + "/entries/"
LOADER_DIR = EFI_DIR + "/" + systemd_boot_manager.DISTRO + "/"
CONF_FILE = [CLEAN_DIR + systemd_boot_manager.DISTRO, ".conf"]

# Default Flags
ROOT_FLAGS = "quiet splash"
RECOVERY_FLAGS = "ro recovery nomodeset"

# System Settings
SETTINGS = systemd_boot_manager.get_settings(VERBOSE)

# make sure settings are valid
if "standard_boot_args" not in SETTINGS:
    SETTINGS["standard_boot_args"] = ROOT_FLAGS
if "recovery_args" not in SETTINGS:
    SETTINGS["recovery_args"] = RECOVERY_FLAGS
if "key" not in SETTINGS:
    SETTINGS["key"] = "partuuid"

# Default Loader Conf File
# We have to edit this in several places, multiple different times.
# Having the default file as a list like this will make that faster
if os.path.exists("../../systemd-boot-manager/root_device.conf"):
    # this is the easiest solution for the user, but takes more processing for us
    with open("../../systemd-boot-manager/root_device.conf", "r") as file:
         ROOT_POINTER = file.read()
    ROOT_POINTER = ROOT_POINTER.split("\n")[0]
    ROOT_POINTER = systemd_boot_manager.get_key(ROOT_POINTER, SETTINGS["key"])
    if SETTINGS["key"].lower() is not "path":
        ROOT_POINTER = f"{ SETTINGS['key'].upper() }={ ROOT_POINTER }"
elif os.path.exists("../../systemd-boot-manager/UUID.conf"):
    # this takes less processing from us, but we have to figure out if this is a UUID or PARTUUID
    with open("../../systemd-boot-manager/UUID.conf", "r") as file:
        ROOT_POINTER = file.read()
    ROOT_POINTER = ROOT_POINTER.split("\n")[0]
    uuids = json.loads(subprocess.check_output(["lsblk", "--json",
                                                "--output", "path,uuid,partuuid,label"]))
    uuids = uuids["blockdevices"]
    for each in uuids:
        if ROOT_POINTER == each["uuid"]:
            ROOT_POINTER = f"UUID={ ROOT_POINTER }"
            break
        elif ROOT_POINTER == each["partuuid"]:
            ROOT_POINTER = f"PARTUUID={ ROOT_POINTER }"
            break
        elif ROOT_POINTER == each["label"]:
            ROOT_POINTER = f"LABEL={ ROOT_POINTER }"
            break
else:
    # this entire block exists to improve stability and resliancy. In case one of the 2 files we looked for perviously don't exist, we still have other options.
    systemd_boot_manager.eprint(systemd_boot_manager.WARNING + "Could not find settings files that point to root partition. Will attempt to infer..." + systemd_boot_manager.CLEAR)
    devices = json.loads(subprocess.check_output(["lsblk", "--json", "--output"
                                                  "mountpoint,partuuid"]))
    devices = devices["blockdevices"]
    root = ""
    for each in devices:
        if each["mountpoint"] == "/":
            root = each["partuuid"]
            break
    if root == "":
        systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "Could not infer root parition." + systemd_boot_manager.CLEAR)
        sys.exit(2)
    ROOT_POINTER = f"PARTUUID={ root }"
CONF_FILE_CONTENTS = ["title  " + systemd_boot_manager.DISTRO,
                      "linux   /" + systemd_boot_manager.DISTRO + "/vmlinuz",
                      "initrd  /" + systemd_boot_manager.DISTRO + "/initrd.img",
                      "options root=" + ROOT_POINTER]
if len(sys.argv) > 1:
    if sys.argv[1] == "-v":
        VERBOSE = True


def check_for_files(files):
    """Check for files needed.

    Returns True if all files are present,
    False if any file is missing.
    """
    for each in files:
        if not os.path.exists(each):
            return False
    return True

def clean_up():
    """This function just makes sure things are unmounted and temporary files are deleted."""
    __umount__("/tmp/sdm-mountpoint")


def failure(exit_code):
    """Consistent Failure output"""
    systemd_boot_manager.eprint(systemd_boot_manager.NAME + "\t" + systemd_boot_manager.RED + "SYSTEMD-BOOT UPDATES FAILED!" + systemd_boot_manager.CLEAR)
    clean_up()
    sys.exit(exit_code)


def warning(output):
    systemd_boot_manager.eprint(systemd_boot_manager.WARNING + output + systemd_boot_manager.CLEAR)

def status(output):
    print(systemd_boot_manager.STATUS + output + systemd_boot_manager.CLEAR)

def success(output):
    print(systemd_boot_manager.SUCCESS + output + systemd_boot_manager.CLEAR)

def error(output):
    systemd_boot_manager.eprint(systemd_boot_manager.ERROR + output + systemd_boot_manager.CLEAR)


def get_esp_part_used():
    """Get amount of ESP partition used"""
    used = subprocess.check_output(["du", "-bs", EFI_DIR]).decode()
    return int(used.split("\t")[0])


def __mount__(device, path_dir):
    """Mount device at path
    It would be much lighter weight to use ctypes to do this
    But, that keeps throwing an 'Invalid Argument' error.
    Calling Mount with check_call is the safer option.
    """
    try:
        subprocess.check_call(["mount", device, path_dir],
                              stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        __umount__(path_dir)
        subprocess.check_call(["mount", device, path_dir],
                              stderr=subprocess.DEVNULL)


def __umount__(path_dir):
    try:
        subprocess.check_call(["umount", path_dir],
                              stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        try:
            subprocess.check_call(["umount", "-l", path_dir],
                                  stderr=subprocess.DEVNULL)
        except subprocess.CalledProcessError as err:
            pass



# Check to make sure we are running as Python3, not 2
if sys.version_info[0] == 2:
    error("Please run with Python 3 as Python 2 is End-of-Life.")
    sys.exit(2)

if not systemd_boot_manager.is_enabled():
    warning("systemd-boot-manager is disabled. Exiting without modifying anything.")
    status("You can re-enable systemd-boot-manager with `sudo update-systemd-boot --enable'")
    sys.exit(0)

print(systemd_boot_manager.STATUS + "UPDATING KERNELS AVAILABLE TO SYSTEMD-BOOT" + systemd_boot_manager.CLEAR)
# Get our UUID
with open(f"{systemd_boot_manager.CONFIG_DIR}/UUID.conf", "r") as uuid_conf:
    UUID = uuid_conf.read()

# Make sure that if there is a trailing new line, we parse it out
UUID = UUID.split("\n")[0]

# Get size of /boot/efi partition
PARTS = json.loads(subprocess.check_output(["lsblk", "--output",
                                            "TYPE,SIZE,NAME,MOUNTPOINT,UUID",
                                            "--json",
                                            "--bytes"]).decode().replace("I",
                                                                         "i"))["blockdevices"]

for each in range(len(PARTS) - 1, -1, -1):
    if ((PARTS[each]["type"] != "disk") or ("children" not in PARTS[each])):
        del PARTS[each]

ESP_SIZE = 0
ESP_UUID = None
for each in PARTS:
    for each1 in each["children"]:
        if "mountpoint" not in each1:
            continue
        if each1["mountpoint"] == EFI_DIR:
            ESP_SIZE = each1["size"]
            ESP_UUID = each1["uuid"] # this will be helpful with handling dual-boot
            break
    if ESP_SIZE != 0:
        break

# Do a quick bit of clean up
del each, PARTS

# Get our kernels
KERNELS = os.listdir(BOOT_DIR)

# Filter down to just the Kernel Images
for each in range(len(KERNELS) - 1, -1, -1):
    if "vmlinuz-" not in KERNELS[each]:
        del KERNELS[each]
    # Remove dpkg-tmp images
    elif ".dpkg-tmp" in KERNELS[each][-9:]:
        del KERNELS[each]
    else:
        # These are kernel images. We need to make this their full file path.
        KERNELS[each] = BOOT_DIR + KERNELS[each]

# Check to make sure we have kernels to work with
if len(KERNELS) < 1:
    error("NO KERNELS FOUND IN /boot")
    failure(1)

# Perform a nuclear clean to ensure everything is always in perfect sync.
# We need to make sure we have some error catching here. Hence all the try/except blocks
try:
    DEATH_ROW = os.listdir(CLEAN_DIR)
    for each in DEATH_ROW:
        if each[-5:] == ".conf":
            try:
                os.remove(CLEAN_DIR + each)
            except FileNotFoundError:
                pass
            except PermissionError:
                error("CANNOT CLEAN ENTRIES DIRECTORY. RUNNING AS ROOT?")
                failure(2)
except FileNotFoundError:
    warning("PREVIOUS ENTRIES NOT FOUND. NOT CLEANING.")

try:
    shutil.rmtree(LOADER_DIR)
except FileNotFoundError:
    pass
except PermissionError:
    error("CANNOT DELETE LOADER DIRECTORY. RUNNING AS ROOT?")
    failure(2)
except NotADirectoryError:
    os.remove(LOADER_DIR)

try:
    os.mkdir(LOADER_DIR)
except FileExistsError:
    pass
except PermissionError:
    error("CANNOT REMAKE LOADER DIRECTORY. RUNNING AS ROOT?")
    failure(2)


# Copy the latest kernel files to a consistent place so we can keep
# using the same loader configuration
for each in enumerate(KERNELS):
    KERNELS[each[0]] = KERNELS[each[0]][14:]

try:
    del KERNELS[KERNELS.index(".old")]
except ValueError:
    pass

# Sort remaining kernels, get latest
KERNELS = sorted(KERNELS, key=LooseVersion)
LATEST = KERNELS[-1]

# Delete latest kernel from the list, so we don't have two entries for it
del KERNELS[-1]

# Let the user know what kernel they will be booting with next time
print(systemd_boot_manager.NAME + "\t" + systemd_boot_manager.GREEN + LATEST + systemd_boot_manager.CLEAR)

# Time for the real work
# We need to make sure the files we need ACTUALLY EXIST first
# Otherwise we can end up with a FileNotFoundError
NEEDED_FILES1 = []
for FILE in NEEDED_FILES:
    NEEDED_FILES1.append(BOOT_DIR + FILE + "-" + LATEST)
if check_for_files(NEEDED_FILES1):
    # We know the files we need exist. Copy them.
    for each in enumerate(NEEDED_FILES1):
        try:
            if VERBOSE:
                print(NEEDED_FILES1[each[0]] + " -> " + LOADER_DIR + NEEDED_FILES[each[0]])
            shutil.copyfile(NEEDED_FILES1[each[0]],
                            LOADER_DIR + NEEDED_FILES[each[0]])
        except FileExistsError:
            os.remove(LOADER_DIR + NEEDED_FILES[each[0]])
            shutil.copyfile(NEEDED_FILES1[each[0]],
                            LOADER_DIR + NEEDED_FILES[each[0]])
        except PermissionError:
            error("CANNOT COPY LOADER FILES. RUNNING AS ROOT?")
            failure(2)
else:
    warning("SOME FILE THAT IS NEEDED DOES NOT EXIST.")
    warning("IT WILL LIKELY BE GENERATED LATER.")
    warning("DIFFERING UPDATE.")
    warning("IF YOU DO NOT GET A SUCCESSFUL UPDATE LATER")
    warning("CALL `sudo update-systemd-boot' TO MANUALLY")
    warning("TRIGGER THE UPDATE. IF YOU STILL HAVE ISSUES")
    warning("SOMETHING ELSE MAY BE WRONG.")
    sys.exit()

# Make sure directory structure is good
if not os.path.exists(CLEAN_DIR):
    directory = ""
    for each in CLEAN_DIR.split("/"):
        if directory == "/":
            directory = directory + each
        else:
            directory = directory + "/" + each
        try:
            os.mkdir(directory)
        except FileExistsError:
            pass

# Generate Config Files
with open("".join(CONF_FILE), "w+") as output:
    output.write("\n".join(CONF_FILE_CONTENTS) + UUID + " " + SETTINGS["standard_boot_args"])
with open("_Recovery".join(CONF_FILE), "w+") as output:
    for each in enumerate(CONF_FILE_CONTENTS):
        if each[0] == 0:
            output.write(CONF_FILE_CONTENTS[each[0]] + " Recovery")
        elif each[0] == len(CONF_FILE_CONTENTS) - 1:
            output.write(CONF_FILE_CONTENTS[each[0]] + UUID + " " + SETTINGS["recovery_args"])
        else:
            output.write(CONF_FILE_CONTENTS[each[0]])
        output.write("\n")

# check loader file
systemd_boot_manager.check_loader()


# Legacy Kernel Support
LOW_SPACE_BREAK = False
LOW_SPACE_LIMIT = 83886080
if len(KERNELS) >= 1:
    for VERSION in KERNELS:
        # Let the user know they have a legacy kernel, in case something breaks
        # And mark it clearly as legacy by putting the "LEGACY" in Blue, in all caps
        REMAINING = ESP_SIZE - get_esp_part_used()
        if REMAINING < LOW_SPACE_LIMIT:
            LOW_SPACE_BREAK = True
            break
        print(systemd_boot_manager.NAME + "\t" + systemd_boot_manager.GREEN + VERSION + systemd_boot_manager.BLUE + "\t(LEGACY)" + systemd_boot_manager.CLEAR)
        for FILE in NEEDED_FILES:
            try:
                if VERBOSE:
                    print(BOOT_DIR + FILE + "-" + VERSION + " -> " + LOADER_DIR + FILE + "-" + VERSION)
                shutil.copyfile(BOOT_DIR + FILE + "-" + VERSION,
                                LOADER_DIR + FILE + "-" + VERSION)
            except FileNotFoundError:
                warning("SOME FILE THAT IS NEEDED DOES NOT EXIST.")
                warning("IT WILL LIKELY BE GENERATED LATER.")
                warning("DIFFERING UPDATE.")
                warning("IF YOU DO NOT GET A SUCCESSFUL UPDATE LATER")
                warning("CALL `sudo update-systemd-boot' TO MANUALLY")
                warning("TRIGGER THE UPDATE. IF YOU STILL HAVE ISSUES")
                warning("SOMETHING ELSE MAY BE WRONG.")
                sys.exit()
            except OSError:
                warning("NOT ENOUGH SPACE ON /boot/efi TO SET UP ALL LEGACY KERNELS.")
                warning("YOUR SYSTEM WILL STILL BOOT, BUT WILL NOT BE ABLE TO BOOT USING")
                warning("ALL INSTALLED KERNELS. UNINSTALL SOME KERNELS TO FIX THIS WARNING.")
                sys.exit()
            except FileExistsError:
                os.remove(LOADER_DIR + FILE)
                shutil.copyfile(BOOT_DIR + FILE + "-" + VERSION,
                                LOADER_DIR + FILE + "-" + VERSION)
            except PermissionError:
                systemd_boot_manager.eprint(systemd_boot_manager.ERROR, end="")
                systemd_boot_manager.eprint("CANNOT COPY LEGACY LOADER FILES. RUNNING AS ROOT?", end="")
                systemd_boot_manager.eprint(systemd_boot_manager.CLEAR)
                failure(2)
        with open(("-" + VERSION).join(CONF_FILE), "w+") as output:
            line = 0
            for each in CONF_FILE_CONTENTS:
                if line == 0:
                    output.write(each + " " + VERSION + "\n")
                elif line in (1, 2):
                    output.write(each + "-" + VERSION + "\n")
                else:
                    output.write(each + UUID + " " + SETTINGS["standard_boot_args"])
                line += 1
        # Also make sure they have Legacy recovery. Cause it can be a life saver.
        with open(("-" + VERSION + "_Recovery").join(CONF_FILE),
                  "w+") as output:
            line = 0
            for each in CONF_FILE_CONTENTS:
                if line == 0:
                    output.write(each + " " + VERSION + " Recovery\n")
                elif line in (1, 2):
                    output.write(each + "-" + VERSION + "\n")
                else:
                    output.write(each + UUID + " " + SETTINGS["recovery_args"])
                line += 1

# Finally, we are done! Woot!
# ... With the Kernels ...
# Now for systemd-boot
REMAINING = ESP_SIZE - get_esp_part_used()
if REMAINING < 200000:
    error("NOT ENOUGH SPACE ON DRIVE TO UPDATE SYSTEMD-BOOT")
    failure(1)
print(systemd_boot_manager.STATUS + "UPDATING SYSTEMD-BOOT VERSIONS" + systemd_boot_manager.CLEAR)
os.putenv("SYSTEMD_RELAX_ESP_CHECKS", "1")
try:
    cmd = ["bootctl", "update", "--graceful"]
    if "no-var" in SETTINGS:
        if SETTINGS["no-var"] is True: # while verbose, we want to ensure this is actually set to true. Any other time, evaluate to False
            cmd.append("--no-variables")
    subprocess.check_call(cmd)
except subprocess.CalledProcessError:
    error("BOOTCTL HAS HAD AN ERROR!")
    failure(2)

# Get default bootloader entry
DEFAULT = subprocess.check_output(["bootctl", "list",
                                   "--no-pager"]).decode().split("\n")
ENTRIES = []
AE = []
TOGGLE = False
for each in range(len(DEFAULT) - 1, -1, -1):
    if (("title: " in DEFAULT[each]) or ("id: " in DEFAULT[each])):
        if "firmware" in DEFAULT[each].lower():
            continue
        AE.append(list(filter(lambda x: x != "", DEFAULT[each].split(" ")))[-1])
        if TOGGLE:
            ENTRIES.append(AE)
            AE = []
            TOGGLE = False
        else:
            TOGGLE = True


for each in ENTRIES:
    if "(default)" in each:
        DEFAULT = each[0]
        break

# Read Default.conf, find what default entry SHOULD be
# We do this so that if this entry is lost after a CMOS clear, it can be restored.
INTENDED_DEFAULT = "#"
if os.path.isfile(systemd_boot_manager.DEFAULTS_FILE):
    with open(systemd_boot_manager.DEFAULTS_FILE, "r") as conf:
        INTENDED_DEFAULT = conf.read().split()[0]

# Check default entry, change if needed
if INTENDED_DEFAULT != "#":
    if INTENDED_DEFAULT != DEFAULT:
        warning("WRONG BOOT ENTRY DEFAULT DETECTED")
        warning("DEFAULT WAS: " + DEFAULT)
        warning("RESETTING DEFAULT")
        try:
            subprocess.check_output(f"bootctl set-default {INTENDED_DEFAULT} 2>&1",
                                    shell=True)
        except subprocess.CalledProcessError as e:
            error("CANNOT SET INTENDED DEFAULT")
            if "supported boot loader" not in str(e.stdout):
                failure(1)
            error("NOT BOOTED WITH SUPPORTED BOOT LOADER")

        success("SUCCESSFULLY RESET DEFAULT BOOT ENTRY")

other_oss = systemd_boot_manager.get_os_prober()

if LOW_SPACE_BREAK:
    warning("NOT ENOUGH SPACE ON /boot/efi TO SET UP ALL LEGACY KERNELS.")
    warning("YOUR SYSTEM WILL STILL BOOT, BUT WILL NOT BE ABLE TO BOOT USING")
    warning("ALL INSTALLED KERNELS. UNINSTALL SOME KERNELS TO FIX THIS WARNING.")
    if other_oss != [[""]]:
        warning("YOU WILL STILL BE ABLE TO BOOT YOUR OTHER OS INSTALLS, BUT")
        warning("YOU WILL HAVE TO GO THROUGH THE EFI BOOT MANAGER TO DO SO.")
else:
    # other operating systems are our last priority. Users can dual-boot using their EFI boot manager if they have to
    # Windows first since it has a standard EFI layout we can work with on any installation
    mountpoint = "/tmp/sdm-mountpoint"
    if "dual-boot" not in SETTINGS:
        SETTINGS["dual-boot"] = True
    if SETTINGS["dual-boot"] is True:
        for each in other_oss:
            systemd = False
            grub = None
            if len(each) < 4:
                continue
            print(systemd_boot_manager.STATUS + f"CONFIGURING {each[1]}" + systemd_boot_manager.CLEAR)
            if "@" in each[0]:
                part = each[0].split("@")[0]
            else:
                part = each[0]
            if not os.path.exists(mountpoint):
                os.mkdir(mountpoint)
            try:
                __mount__(part, mountpoint)
            except subprocess.CalledProcessError:
                __umount__(mountpoint)
                __mount__(part, mountpoint)
            if each[2] == "Windows":
                # copy over Windows files as needed
                try:
                    shutil.copytree(mountpoint + "/EFI/Microsoft",
                                    EFI_DIR + "/EFI/Microsoft")
                except FileExistsError:
                    # Windows is already set up, delete and reset up in case it's old files
                    shutil.rmtree(EFI_DIR + "/EFI/Microsoft")
                    shutil.copytree(mountpoint + "/EFI/Microsoft",
                                    EFI_DIR + "/EFI/Microsoft")

            else:
                try:
                    os.mkdir(EFI_DIR + "/EFI/" + each[2])
                except FileExistsError:
                    pass
                # read OS FSTAB
                try:
                    with open(mountpoint + "/etc/fstab", "r") as file:
                        fstab = file.read().split("\n")
                except FileNotFoundError:
                    systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "Thought Windows was Linux. Stopping setting up dual-boot now to prevent issues." + systemd_boot_manager.CLEAR)
                    break
                for each1 in fstab:
                    if len(each1) < 1:
                        continue
                    if each1[0] == "#":
                        continue
                    if "/boot/efi" in each1.lower():
                        fstab = each1
                        break
                fstab = fstab.replace("\t", " ")
                end = 0
                for each1 in fstab:
                    if each1.isspace():
                        break
                    end += 1
                start = 1
                for each1 in fstab:
                    if not each1.isalnum():
                        break
                    start += 1
                # the UUID we need to mount
                fstab = fstab[start:end]
                # This SHOULD prevent mounting the same partition in 2 places
                if fstab == ESP_UUID:
                    # they match, so do not mount
                    continue
                blkid = subprocess.check_output(["blkid"]).decode().split("\n")
                for each1 in blkid:
                    if fstab in each1:
                        fstab = each1.split(":")[0]
                        break
                # swap mounted partitions
                __umount__(mountpoint)
                __mount__(fstab, mountpoint)
                # NOW we need to figure out what bootloader is in use
                dirs = os.listdir(mountpoint + "/EFI")
                if "systemd" in dirs:
                    # know they are using systemd-boot as well. We can just clone files and make life easy
                    systemd = True
                    dirs = os.listdir(mountpoint)
                    del dirs[dirs.index("EFI")]
                    del dirs[dirs.index("loader")]
                    for each in dirs:
                        shutil.copytree(mountpoint + "/" + each,
                                        EFI_DIR + "/" + each)
                    dirs = os.listdir(mountpoint + "/loader/entries")
                    for each1 in dirs:
                        count = 0
                        # copy over unique files
                        # there is likely a faster way to do this, but this way should at least:
                        # 1: be reliable
                        # 2: prevent file collisions
                        # 3: prevent duplicate systemd-boot entries
                        while True:
                            if count == 0:
                                if not os.path.exists(CLEAN_DIR + each1):
                                    shutil.copy(mountpoint + "/loader/entries/" + each1,
                                                CLEAN_DIR + each1)
                                    break
                                with open(mountpoint + "/loader/entries/" + each1,
                                        "r") as file:
                                    contents1 = file.read()
                                with open(CLEAN_DIR + each1, "r") as file:
                                    contents2 = file.read()
                                if contents1 == contents2:
                                    # The files match, skip
                                    break
                            else:
                                name = f"-{count}.".join(each1.split("."))
                                if not os.path.exists(CLEAN_DIR + name):
                                    shutil.copy(mountpoint + "/loader/entries/" + each1,
                                                CLEAN_DIR + name)
                                    break
                                with open(mountpoint + "/loader/entries/" + each1,
                                        "r") as file:
                                    contents1 = file.read()
                                with open(CLEAN_DIR + name, "r") as file:
                                    contents2 = file.read()
                                if contents1 == contents2:
                                    # The files match, skip
                                    break
                            count += 1
                else:
                    # systemd-boot is NOT being used
                    try:
                        del dirs[dirs.index("BOOT")]
                    except ValueError:
                        pass
                    try:
                        del dirs[dirs.index("Linux")]
                    except ValueError:
                        pass
                    for each1 in dirs:
                        dirs2 = os.listdir(mountpoint + "/EFI/" + each1)
                        for each2 in dirs2:
                            if each2.lower() == "grubx64.efi":
                                grub = "/EFI/" + each1 + "/" + each2
                        if grub is not None:
                            count = 0
                            src = mountpoint + "/EFI/" + each1
                            dest = EFI_DIR + "/EFI/" + each1
                            try:
                                shutil.copytree(src, dest)
                            except FileExistsError:
                                shutil.rmtree(dest)
                                shutil.copytree(src, dest)
                            break
                    # At this point we have detected either Windows, systemd-boot, or GRUB.
                    # That should cover most Linux OSs and Windows which are the biggest issues.

            # make loader file
            if not systemd:
                with open(CLEAN_DIR + each[2] + ".conf", "w") as file:
                    file.write(f"title {each[1]}\n")
                    if grub is None:
                        # This SHOULD be Windows. An OS like MacOS or a Linux distro using
                        # an unsupported bootloader will result an an empty entry.
                        if each[2].lower() == "windows":
                            file.write("efi /EFI/Microsoft/Boot/bootmgfw.efi")
                    else:
                        # they are using GRUB. Chain-load it.
                        file.write(f"linux {grub}")
                    # ending newline
                    file.write("\n")

clean_up()
success("SYSTEMD-BOOT UPDATES COMPLETE!")
