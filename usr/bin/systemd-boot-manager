#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#  systemd-boot-manager
#
#  Copyright 2022 Thomas Castleman <contact@draugeros.org>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#
"""Explain what this program does here!!!"""
from __future__ import print_function
import sys
import subprocess
import os
import json
import shlex
import systemd_boot_manager as sdbm


# Set up
UUID_FILE = sdbm.CONFIG_DIR + "/root_device.conf"
VERSION = "0.5.3-alpha5"
HELP = f"""systemd-boot-manager, Version: { VERSION }

        --apply-loader-config                            Apply loader.conf config
    -c, --check                                          Check systemd-boot-manager settings.
    -e, --enable                                         Enable systemd-boot-manager.
        --enforce-default-entry=[enable|disable]         Make sure the default boot entry is set correctly
                                                         at every boot.
        --editor=[enable|disable]                        Enable or disable boot menu entry editor.
    -d, --default [bootloader entry]                     Set as default bootloader entry.
        --disable                                        Disable systemd-boot-manager.
        --dual-boot=(enable|disable)                     Enable or disable dual-boot support within systemd-boot.
                                                         Pass nothing to check dual-boot status.
    -h, --help                                           Print this help dialog and exit.
    -l, --list                                           List all bootloader entries.
    -r, --repair                                         Repair systemd-boot-manager settings and systemd-boot.
    -s, --show-settings                                  Show current settings.
    -t, --timeout [timeout in seconds]                   Set boot menu timeout in seconds.
    -u, --update                                         Update systemd-boot, default action.
    -v, --version                                        Print current version and exit.
    -V, --verbose                                        Print what is being done verbosely."""


if sys.version_info[0] == 2:
    sdbm.eprint(sdbm.ERROR + "Please run with Python 3 as Python 2 is End-of-Life." + sdbm.CLEAR)
    sys.exit(2)


def list_boot_entries(verbose):
    """Print a list of boot entries for the user"""
    entries = sdbm.get_boot_entries(verbose=verbose)
    print(sdbm.BLUE + "BOOT LOADER ENTRIES" + sdbm.CLEAR)
    print("-" * 20, "\n")
    for each in entries:
        print(f"\t-  { each }")
        print(f"\t\tID: { entries[each]['id'] }")
        print(f"\t\tDefault: { str(entries[each]['default']) }", '\n')


def enable(verbose):
    """Entry point to enable systemd-boot-manager"""
    if not sdbm.is_root():
        sdbm.eprint(sdbm.ERROR + "You need to be run this program as root to enable systemd-boot-manager." + sdbm.CLEAR)
        sys.exit(2)
    if not sdbm.is_enabled():
        set_enabled()
        print(sdbm.SUCCESS + "systemd-boot-manager enabled!" + sdbm.CLEAR)
        sys.exit(0)
    else:
        print(sdbm.STATUS + "systemd-boot-manager already enabled." + sdbm.CLEAR)
        sys.exit(0)


def disable(verbose):
    """Entry point to disable systemd-boot-manager"""
    if not sdbm.is_root():
        sdbm.eprint(sdbm.ERROR + "You need to be run this program as root to disable systemd-boot-manager." + sdbm.CLEAR)
        sys.exit(2)
    if not sdbm.is_enabled():
        sdbm.eprint(sdbm.STATUS + "systemd-boot-manager already disabled." + sdbm.CLEAR)
        sys.exit(0)
    else:
        set_disabled()
        print(sdbm.SUCCESS + "systemd-boot-manager disabled!" + sdbm.CLEAR)
        sys.exit(0)


def enforce_default_entry(arg, verbose):
    """"""
    if not sdbm.is_root():
        sdbm.eprint(sdbm.ERROR + "You need to run this program as root to enable or disable boot entry enforcment." + sdbm.CLEAR)
        sys.exit(2)
    setting = arg[24:].lower()
    if setting == "enable":
        try:
            subprocess.check_call(["systemctl", "enable", "systemd-boot-manager"])
        except subprocess.CalledProcessError:
            sdbm.eprint(sdbm.ERROR + "systemd has encountered an error." + sdbm.CLEAR)
            sys.exit(2)
        print(sdbm.SUCCESS + "Default Entry Enforcement has been ENABLED" + sdbm.CLEAR)
    elif setting == "disable":
        try:
            subprocess.check_call(["systemctl", "disable", "systemd-boot-manager"])
        except subprocess.CalledProcessError:
            sdbm.eprint(sdbm.ERROR + "systemd has encountered an error." + sdbm.CLEAR)
            sys.exit(2)
        print(sdbm.SUCCESS + "Default Entry Enforcement has been DISABLED" + sdbm.CLEAR)
    elif setting == "":
        try:
            status = subprocess.check_output(["systemctl", "status",
                                              "systemd-boot-manager"]).decode()
        except subprocess.CalledProcessError:
            sdbm.eprint(sdbm.ERROR + "systemd has encountered an error." + sdbm.CLEAR)
            sys.exit(2)
        status = status.split("\n")[1].split("; ")[1]
        print(sdbm.STATUS + f"Default Entry Enforcement is: { status.upper() }" + sdbm.CLEAR)
    else:
        sdbm.eprint(f"{sdbm.ERROR}Invalid option given. Option must be one of either `enable' or `disable'.{sdbm.CLEAR}")


def dual_boot(arg, verbose):
    """Report or update dual-boot setting"""
    with open("/etc/systemd-boot-manager/general.json", "r") as file:
        settings = json.load(file)
    if arg == "":
        if settings["dual-boot"] is True:
            print(sdbm.SUCCESS + "Dual-boot Support is Enabled." + sdbm.CLEAR)
        else:
            print(sdbm.STATUS + "Dual-boot Support is Disabled." + sdbm.CLEAR)
    else:
        arg = arg.lower()
        if arg == "enable":
            if settings["dual-boot"] is True:
                print(sdbm.SUCCESS + "Dual-boot Support is already Enabled." + sdbm.CLEAR)
            else:
                settings["dual-boot"] = True
                with open("/etc/systemd-boot-manager/general.json", "w") as file:
                    json.dump(settings, file, indent=2)
                print(sdbm.SUCCESS + "Dual-boot Support is Enabled." + sdbm.CLEAR)
        elif arg == "disable":
            # we do this because the ONLY time we want dual-boot to be enabled is when dual-boot is True. Any other time, we default to False.
            if settings["dual-boot"] is not True:
                print(sdbm.STATUS + "Dual-boot Support is already Disabled." + sdbm.CLEAR)
            else:
                settings["dual-boot"] = False
                with open("/etc/systemd-boot-manager/general.json", "w") as file:
                    json.dump(settings, file, indent=2)
                print(sdbm.STATUS + "Dual-boot Support is Disabled." + sdbm.CLEAR)
        else:
            sdbm.eprint(sdbm.ERROR + f"'{status}' not understood. Please use either 'enable' or 'disable'.")
            sys.exit(1)


def update(verbose):
    """Trigger systemd-boot update"""
    command = ["/etc/kernel/postinst.d/zz-update-systemd-boot"]
    if verbose:
        command.append("-v")
    if not sdbm.is_root():
        sdbm.eprint(sdbm.ERROR + "You need to be run this program as root to update systemd-boot." + sdbm.CLEAR)
        sys.exit(2)
    try:
        subprocess.check_call(command)
    except subprocess.CalledProcessError as err:
        sys.exit(err.returncode)


def get_settings(verbose):
    """Get current settings"""
    conf = {"KEY": None, "DEFAULT_ENTRY": None}
    if sdbm.check_default_entry(verbose=verbose):
        conf["DEFAULT_ENTRY"] = sdbm.get_default_boot_entry(verbose)
    else:
        raise ValueError("Settings corrupted! Repair recommended!")
    with open("../../etc/systemd-boot-manager/general.json") as file:
        settings = json.load(file)
    conf["KEY"] = settings["key"].upper()
    conf[settings["key"].upper()] = sdbm.get_key(sdbm.get_root_partition(verbose),
                                                 key_type=conf["KEY"],
                                                 verbose=verbose)
    return conf


def show_settings(verbose):
    """Print current settings"""
    print(sdbm.GREEN + "CURRENT SETTINGS" + sdbm.CLEAR)
    print("-" * 20, "\n")
    try:
        settings = get_settings(verbose)
    except ValueError:
        print(sdbm.RED + "\nERROR: SETTINGS LIKELY CORRUPTED!" + sdbm.CLEAR)
        print(sdbm.RED + "\nERROR: REPAIR THIS ISSUE USING THE -r FLAG!\n" + sdbm.CLEAR)
        sys.exit(2)
    print(sdbm.BLUE + "DEFAULT BOOT ENTRY:\t" + sdbm.CLEAR + settings["DEFAULT_ENTRY"])
    devices = _get_devices()
    for each in devices:
        if each["partuuid"] == settings["UUID"]:
            print(sdbm.BLUE + "ROOT PARTITION:\t\t" + sdbm.CLEAR + each["path"])


# Handle flags on command line
# get length of argv
ARGC = len(sys.argv)
VERBOSE = False
POINT = 1
if "update-systemd-boot" in sys.argv[0]:
    HELP = f"""update-systemd-boot, Version: { VERSION }

Update systemd-boot and available kernel stubs

-h, --help       Print this help dialog and exit
-v, --verbose    Print what is being done verbosely
-V, --version    Print systemd-boot-manager version

Pass nothing to trigger an update."""
    if ARGC >= 2:
        if ((sys.argv[1].lower() == "--verbose") or (sys.argv[1] == "-v")):
            update(True)
        elif sys.argv[1].lower() in ("-h", "--help"):
            print(HELP)
        elif ((sys.argv[1].lower() == "--version") or (sys.argv[1] == "-V")):
            print(VERSION)
        else:
            print(HELP)
            sys.exit(1)
    else:
        update(False)
else:
    if ARGC >= 2:
    # check for verbose flag first
        for each in enumerate(sys.argv):
            if sys.argv[each[0]] in ("-v", "--verbose"):
                VERBOSE = True
                POINT = each[0]
                break
        if POINT == 1 and VERBOSE:
            POINT = 2
        else:
            POINT = 1
        if sys.argv[POINT] in ("-h", "--help"):
            print(HELP)
        elif sys.argv[POINT] in ("-V", "--version"):
            print(VERSION)
        elif sys.argv[POINT] in ("-u", "--update"):
            update(VERBOSE)
        elif sys.argv[POINT] in ("-c", "--check"):
            check(VERBOSE)
        elif sys.argv[POINT] in ("-r", "--repair"):
            repair(VERBOSE)
        elif sys.argv[POINT] in ("-s", "--show-settings"):
            show_settings(VERBOSE)
        elif sys.argv[POINT] in ("-l", "--list"):
            list_boot_entries(VERBOSE)
        elif sys.argv[POINT] in ("-d", "--default"):
            if len(sys.argv) < 3:
                sdbm.eprint(sdbm.ERROR + "No default specified." + sdbm.CLEAR)
                sys.exit(2)
            sdbm.set_as_default_entry(sys.argv[POINT + 1])
        elif sys.argv[POINT] in ("-e", "--enable"):
            enable(VERBOSE)
        elif sys.argv[POINT] == "--disable":
            disable(VERBOSE)
        elif "--enforce-default-entry" in sys.argv[POINT]:
            enforce_default_entry(sys.argv[POINT], VERBOSE)
        elif sys.argv[POINT] in ("-t", "--timeout"):
            if not is_root():
                sdbm.eprint(sdbm.ERROR + "You need to run this program as root to change settings." + sdbm.CLEAR)
                sys.exit(2)
            if ((len(sys.argv) - 1) > (POINT + 1)):
                sdbm.eprint(f"{sdbm.ERROR}No option given. Option must be a positive integer.{sdbm.CLEAR}")
            set_timeout(timeout=sys.argv[POINT + 1], verbose=VERBOSE)
        elif sys.argv[POINT] == "--apply-loader-config":
            if not is_root():
                sdbm.eprint(sdbm.ERROR + "You need to run this program as root to change settings." + sdbm.CLEAR)
                sys.exit(2)
            apply_loader(verbose=VERBOSE)
        elif "--editor" in sys.argv[POINT]:
            if not is_root():
                sdbm.eprint(sdbm.ERROR + "You need to run this program as root to change settings." + sdbm.CLEAR)
                sys.exit(2)
            setting = sys.argv[POINT][9:].lower()
            set_editor(enable=setting, verbose=VERBOSE)
        elif "--dual-boot" in sys.argv[POINT]:
            arg = sys.argv[POINT][12:]
            dual_boot(arg, VERBOSE)
        else:
            sdbm.eprint(sdbm.ERROR + "Flag: " + sys.argv[1] + " Not understood." + sdbm.CLEAR)
            print(HELP)
            sys.exit(1)
    else:
        print(HELP)
