#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#  update-systemd-boot
#
#  Copyright 2020 Thomas Castleman <contact@draugeros.org>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#
"""Trigger zz-update-systemd-boot"""
from __future__ import print_function
import sys
import subprocess
import os
import json

GREEN = "\033[92m"
RED = "\033[91m"
CLEAR = "\033[0m"
YELLOW = "\033[93m"
BLUE = '\033[94m'
ERROR = RED + "ERROR: " + CLEAR
WARNING = YELLOW + "WARNING: " + CLEAR

CONFIG_DIR = "/etc/systemd-boot-manager"
UUID_FILE = CONFIG_DIR + "/UUID.conf"
DEFAULTS_FILE = CONFIG_DIR + "/default_entry.conf"

VERSION = "0.0.8-alpha0"
HELP = """systemd-boot-manager, Version: %s

\t-c, --check\t\t\t\tCheck systemd-boot-manager settings.
\t-d, --default [bootloader entry]\tSet as default bootloader entry.  (Not yet implemented)
\t-h, --help\t\t\t\tPrint this help dialog and exit.
\t-l, --list\t\t\t\tList all bootloader entries.
\t-r, --repair\t\t\t\tRepair systemd-boot-manager settings and systemd-boot.
\t-u, --update\t\t\t\tUpdate systemd-boot, default action.
\t-v, --version\t\t\t\tPrint current version and exit.""" % (VERSION)


def __eprint__(*args, **kwargs):
    """Make it easier for us to print to stderr"""
    print(*args, file=sys.stderr, **kwargs)


if sys.version_info[0] == 2:
    __eprint__(ERROR + "Please run with Python 3 as Python 2 is End-of-Life.")
    sys.exit(2)


def trigger():
    """Trigger systemd-boot update"""
    if os.geteuid() != 0:
        __eprint__(ERROR + "You need to be run this program as root to update systemd-boot." + CLEAR)
        sys.exit(2)
    try:
        subprocess.check_call(["/etc/kernel/postinst.d/zz-update-systemd-boot"])
    except subprocess.CalledProcessError as err:
        sys.exit(err.returncode)


def get_UUID():
    """Get UUID for the root partition"""
    # Get root partition
    root_part = ""
    try:
        devices = json.loads(subprocess.check_output(["lsblk", "--output",
                                                      "NAME,MOUNTPOINT",
                                                      "--json",
                                                      "--paths"]).decode().replace("I", "i"))
    except subprocess.CalledProcessError as err:
        __eprint__(ERROR + "CANNOT GET ROOT PARTITION UUID. LSBLK FAILED." + CLEAR)
        __eprint__("The error was: ")
        __eprint__(err.output)
        sys.exit(err.returncode)
    devices = devices["blockdevices"]
    for each in range(len(devices) - 1, -1, -1):
        if "loop" in devices[each]["name"]:
            del devices[each]
    for each in devices:
        if "children" in each:
            for each1 in each["children"]:
                if each1["mountpoint"] == "/":
                    root_part = each1["name"]
                    break
        if root_part != "":
            break
    # Clean up
    del devices
    # Get our UUID
    try:
        uuid = subprocess.check_output(["blkid", "-s", "PARTUUID", "-o",
                                        "value", root_part]).decode()[:-1]
    except subprocess.CalledProcessError as err:
        __eprint__(ERROR + "CANNOT GET ROOT PARTITION UUID. BLKID FAILED." + CLEAR)
        __eprint__("The error was: ")
        __eprint__(err.output)
        sys.exit(err.returncode)
    return uuid


def get_boot_entries():
    """Get bootloader entries"""
    DEFAULT = subprocess.check_output(["bootctl", "list", "--no-pager"]).decode().split("\n")
    for each in range(len(DEFAULT) - 1, -1, -1):
        if "title: " not in DEFAULT[each]:
            del DEFAULT[each]
            continue
        DEFAULT[each] = " ".join(DEFAULT[each].split()[1:])
    return DEFAULT


def get_default_boot_entry():
    """Get default bootloader entry"""
    DEFAULT = get_boot_entries()
    for each in range(len(DEFAULT) - 1, -1, -1):    
        if "Reboot Into Firmware Interface" in DEFAULT[each]:
            del DEFAULT[each]
    for each in DEFAULT:
        if "(default)" in each:
            DEFAULT = " ".join(each.split()[:-1])

    # Get just the ID
    DEFAULT = DEFAULT.split("(")[1][:-1]

    return DEFAULT


def generate_settings(uuid, default_entry=None):
    """Generate settings based off the current system,
    Or, passed settings
    """
    DEFAULTS_FILE_ADDON = """# This file defines the default boot entry that systemd-boot should be using.
    # It only reads the first line, but these other lines are being commented out like
    # in a shell script because if this file gets renamed and used for other purposes,
    # then this syntax will be honored
    #
    # That first line needs to be the Entry ID you want to be default from
    # `bootctl list`
    #
    # If you don't want systemd-boot-manager changing the default entry, just comment that
    # first line out and it will not do anything."""
    try:
        with open(UUID_FILE, "w") as conf:
            conf.write(uuid)
    except (FileNotFoundError, PermissionError) as err:
        __eprint__(ERROR + "An Unwarrented error has occured. Please try again later." + CLEAR)
        __eprint__("The error reported was:")
        __eprint__(err.output)
        sys.exit(err.returncode)
    try:
        with open(DEFAULTS_FILE, "w") as conf:
            if default_entry is not None:
                conf.write(default_entry)
            else:
                conf.write("# Drauger_OS.conf")
            conf.write("\n")
            conf.write(DEFAULTS_FILE_ADDON)
    except (FileNotFoundError, PermissionError) as err:
        __eprint__(ERROR + "An Unwarrented error has occured. Please try again later." + CLEAR)
        __eprint__("The error reported was:")
        __eprint__(err.output)
        sys.exit(err.returncode)


def check():
    """Check systemd-boot-manager settings"""
    # This is like a report for use to use to explain to the user later
    # How their config is doing
    report = {"UUID":None, "DEFAULT": None}
    if os.path.isfile(UUID_FILE):
        with open(UUID_FILE, "r") as conf:
            uuid_stored = conf.read()
        if uuid_stored[-1] == "\n":
            uuid_stored = uuid_stored[:-1]
        uuid_generated = get_UUID()
        if uuid_stored == uuid_generated:
            report["UUID"] = True
        else:
            report["UUID"] = False
    if os.path.isfile(DEFAULTS_FILE):
        intended_default = "#"
        with open(DEFAULTS_FILE, "r") as conf:
            intended_default = conf.read().split()[0]
        default = get_default_boot_entry()
        if default == intended_default:
            report["DEFAULT"] = True
        elif intended_default != "#":
            report["DEFAULT"] = False

    print(BLUE + "RUNNING CONFIGURATION CHECKS" + CLEAR)
    print("-" * 20, "\n")
    errors = 0
    for each in report:
        if each == "UUID":
            if report["UUID"]:
                print(BLUE + "UUID: " + GREEN + "GOOD" + CLEAR)
            else:
                print(BLUE + "UUID: " + RED + "MISMATCH" + CLEAR)
                errors += 1
        if each == "DEFAULT":
            if report["DEFAULT"] is True:
                print(BLUE + "DEFAULT BOOTLOADER ENTRY: " + GREEN + "GOOD" + CLEAR)
            elif report["DEFAULT"] is False:
                print(BLUE + "DEFAULT BOOTLOADER ENTRY: " + RED + "MISMATCH" + CLEAR)
                errors += 1
            else:
                print(BLUE + "DEFAULT BOOTLOADER ENTRY: " + YELLOW + "NOT CONTROLLING" + CLEAR)
    if errors != 0:
        print(RED + "\nTHERE ARE ERRORS!\n" + CLEAR)
        print("We suggest running `sudo update-systemd-boot --repair' to fix these issues.")
        sys.exit(1)


def repair():
    """Repair systemd-boot-manager and systemd-boot settings"""
    if os.geteuid() != 0:
        __eprint__(ERROR + "You need to be run this program as root to repair your settings." + CLEAR)
        sys.exit(2)
    print(BLUE + "INITIATING CONFIGURATION REPAIR" + CLEAR)
    print("-" * 20, "\n")
    # Get UUID
    print(BLUE + "GETTING APPRORIATE SETTINGS" + CLEAR)
    UUID = get_UUID()
    # Get default entry
    default_entry = get_default_boot_entry()
    # Make them permanent
    print(BLUE + "WRITING SETTINGS TO DISK" + CLEAR)
    generate_settings(UUID, default_entry=default_entry)
    print("\n")
    check()
    
    
def set_as_default_entry(entry):
    """Set 'entry' as the default bootloader entry"""
    __eprint__(ERROR + "NOT IMPLEMENTED YET." + CLEAR)
    sys.exit(1)


# get length of argv
ARGC = len(sys.argv)
if ARGC >= 2:
    if sys.argv[1] in ("-h", "--help"):
        print(HELP)
    elif sys.argv[1] in ("-v", "--version"):
        print(VERSION)
    elif sys.argv[1] in ("-u", "--update"):
        trigger()
    elif sys.argv[1] in ("-c", "--check"):
        check()
    elif sys.argv[1] in ("-r", "--repair"):
        repair()
    elif sys.argv[1] in ("-l", "--list"):
        entries = get_boot_entries()
        print(BLUE + "BOOT LOADER ENTRIES" + CLEAR)
        print("-" * 20, "\n")
        for each in entries:
            if type(each) == str:
                print("\t-  " + each)
            elif type(each) == list:
                print("\t-  " + each[0])
    elif sys.argv[1] in ("-d", "--default"):
        if len(sys.argv) < 3:
              __eprint__(ERROR + "No default specified." + CLEAR)
              sys.exit(2)
        set_as_default_entry(sys.argv[2])
    else:
        __eprint__(ERROR + "Flag: " + sys.argv[1] + " Not understood.")
        print(HELP)
        sys.exit(1)
else:
    trigger()
