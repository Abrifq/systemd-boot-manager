#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#  update-systemd-boot
#
#  Copyright 2021 Thomas Castleman <contact@draugeros.org>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#
"""Trigger zz-update-systemd-boot"""
from __future__ import print_function
import sys
import subprocess
import os
import json
import systemd_boot_manager



UUID_FILE = systemd_boot_manager.CONFIG_DIR + "/UUID.conf"


VERSION = "0.1.7-alpha1"
HELP = """systemd-boot-manager, Version: %s

    -c, --check                         Check systemd-boot-manager settings.
    -e, --enable                        Enable systemd-boot-manager.
    -d, --default [bootloader entry]    Set as default bootloader entry.
        --disable                       Disable systemd-boot-manager.
    -h, --help                          Print this help dialog and exit.
    -l, --list                          List all bootloader entries.
    -r, --repair                        Repair systemd-boot-manager settings and systemd-boot.
    -s, --show-settings                 Show current settings.
    -u, --update                        Update systemd-boot, default action.
    -v, --version                       Print current version and exit.
    -V, --verbose                       Print what is being done verbosely""" % (VERSION)


if sys.version_info[0] == 2:
    systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "Please run with Python 3 as Python 2 is End-of-Life.")
    sys.exit(2)


def is_root():
    """Check if we have root"""
    return (os.geteuid() == 0)

def trigger(verbose):
    """Trigger systemd-boot update"""
    command = ["/etc/kernel/postinst.d/zz-update-systemd-boot"]
    if verbose:
        command.append("-v")
    if not is_root():
        systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "You need to be run this program as root to update systemd-boot." + systemd_boot_manager.CLEAR)
        sys.exit(2)
    try:
        subprocess.check_call(command)
    except subprocess.CalledProcessError as err:
        sys.exit(err.returncode)


def _get_devices():
    """Get devices from LSBLK"""
    try:
        devices = json.loads(subprocess.check_output(["lsblk", "--output",
                                                      "PATH,TYPE,MOUNTPOINT,PARTUUID",
                                                      "--json",
                                                      "--paths"]).decode().replace("I", "i"))
    except subprocess.CalledProcessError as err:
        systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "CANNOT GET ROOT PARTITION UUID. LSBLK FAILED." + systemd_boot_manager.CLEAR)
        systemd_boot_manager.eprint("The error was: ")
        systemd_boot_manager.eprint(err.output)
        sys.exit(err.returncode)
    devices = devices["blockdevices"]
    for each in range(len(devices) - 1, -1, -1):
        if "loop" == devices[each]["type"]:
            del devices[each]
    return devices


def get_UUID(verbose):
    """Get UUID for the root partition"""
    # Get root partition
    uuid = ""
    print("getting devices . . .")
    devices = _get_devices()
    print("Parsing for UUIDs . . .")
    for each in devices:
        if each["mountpoint"] == "/":
            uuid = each["partuuid"]
            break
    return uuid


def get_boot_entries(verbose=False):
    """Get bootloader entries"""
    print("Getting boot entry list . . .")
    entries = subprocess.check_output(["bootctl", "list", "--no-pager"]).decode().split("\n")
    output = {}
    name = ""
    print("Parsing List. . .")
    for each in entries:
        if "title: " in each:
            if "(default)" in each:
                output[" ".join(each.split()[1:])[:-10]] = {"default":True}
                name = " ".join(each.split()[1:])[:-10]
            else:
                output[" ".join(each.split()[1:])] = {"default":False}
                name = " ".join(each.split()[1:])
        elif "id: " in each:
            output[name]["id"] = each.split()[-1]
    return output


def get_default_boot_entry(verbose):
    """Get default bootloader entry"""
    entries = get_boot_entries(verbose=verbose)
    print("Checking parsed data for 'default' flag . . .")
    for each in entries:
        if entries[each]["default"] is True:
            return entries[each]["id"]


def update_defaults_file(default_entry, verbose=False):
    """Write default bootloader entry to config file"""
    DEFAULTS_FILE_ADDON = """# This file defines the default boot entry that systemd-boot should be using.
    # It only reads the first line, but these other lines are being commented out like
    # in a shell script because if this file gets renamed and used for other purposes,
    # then this syntax will be honored
    #
    # That first line needs to be the Entry ID you want to be default from
    # `bootctl list`
    #
    # If you don't want systemd-boot-manager changing the default entry, just comment that
    # first line out and it will not do anything."""
    try:
        if verbose:
            print("Writing default boot entry to " + systemd_boot_manager.DEFAULTS_FILE + " . . .")
        with open(systemd_boot_manager.DEFAULTS_FILE, "w") as conf:
            if default_entry is not None:
                conf.write(default_entry)
            else:
                if verbose:
                    print("No default set, writing dummy value . . .")
                conf.write("# default_entry_here.conf")
            conf.write("\n")
            conf.write(DEFAULTS_FILE_ADDON)
    except (FileNotFoundError, PermissionError) as err:
        systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "An Unwarrented error has occured. Please try again later." + systemd_boot_manager.CLEAR)
        sys.exit(2)


def generate_settings(uuid, default_entry=None, verbose=False):
    """Generate settings based off the current system,
    Or, passed settings
    """
    try:
        if verbose:
            print("Writing UUID settings to " + UUID_FILE + " . . .")
        with open(UUID_FILE, "w") as conf:
            conf.write(uuid)
    except (FileNotFoundError, PermissionError) as err:
        systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "An Unwarrented error has occured. Please try again later." + systemd_boot_manager.CLEAR)
        sys.exit(2)
    update_defaults_file(default_entry, verbose=verbose)


def _check_default_entry(verbose=False):
    """Confirm default boot entry is correct"""
    intended_default = "#"
    if verbose:
        print("Reading defaults file . . .")
    with open(systemd_boot_manager.DEFAULTS_FILE, "r") as conf:
        intended_default = conf.read().split()[0]
    default = get_default_boot_entry(verbose)
    if verbose:
        print("Comparing defaults file to defaults in memory . . .")
    if default == intended_default:
        return True
    elif intended_default != "#":
        return False


def _check_uuid(verbose=False):
    """Check correct UUID is in use"""
    if verbose:
        print("Reading UUID file . . .")
    with open(UUID_FILE, "r") as conf:
        uuid_stored = conf.read()
    if uuid_stored[-1] == "\n":
        uuid_stored = uuid_stored[:-1]
    uuid_generated = get_UUID(verbose)
    if verbose:
        print("Comparing UUID file to UUID in memory . . .")
    return (uuid_stored == uuid_generated)


def check(verbose):
    """Check systemd-boot-manager settings"""
    # This is like a report for use to use to explain to the user later
    # How their config is doing
    report = {"UUID":None, "DEFAULT": None}
    if verbose:
        print("Reading config files . . .")
    if os.path.isfile(UUID_FILE):
        report["UUID"] = _check_uuid(verbose=verbose)
    if os.path.isfile(systemd_boot_manager.DEFAULTS_FILE):
        report["DEFAULT"] = _check_default_entry(verbose=verbose)

    print(systemd_boot_manager.BLUE + "RUNNING CONFIGURATION CHECKS" + systemd_boot_manager.CLEAR)
    print("-" * 20, "\n")
    errors = 0
    for each in report:
        if verbose:
            print("Checking UUID . . .")
        if each == "UUID":
            if report["UUID"]:
                print(systemd_boot_manager.BLUE + "UUID: " + systemd_boot_manager.GREEN + "GOOD" + systemd_boot_manager.CLEAR)
            else:
                print(systemd_boot_manager.BLUE + "UUID: " + systemd_boot_manager.RED + "MISMATCH" + systemd_boot_manager.CLEAR)
                errors += 1
        if verbose:
            print("Checking default entry . . .")
        if each == "DEFAULT":
            if report["DEFAULT"] is True:
                print(systemd_boot_manager.BLUE + "DEFAULT BOOTLOADER ENTRY: " + systemd_boot_manager.GREEN + "GOOD" + systemd_boot_manager.CLEAR)
            elif report["DEFAULT"] is False:
                print(systemd_boot_manager.BLUE + "DEFAULT BOOTLOADER ENTRY: " + systemd_boot_manager.RED + "MISMATCH" + systemd_boot_manager.CLEAR)
                errors += 1
            else:
                print(systemd_boot_manager.BLUE + "DEFAULT BOOTLOADER ENTRY: " + systemd_boot_manager.YELLOW + "NOT CONTROLLING" + systemd_boot_manager.CLEAR)
    if errors != 0:
        print(systemd_boot_manager.RED + "\nTHERE ARE ERRORS!\n" + systemd_boot_manager.CLEAR)
        print("We suggest running `sudo update-systemd-boot --repair' to fix these issues.")
        sys.exit(1)


def repair(verbose):
    """Repair systemd-boot-manager and systemd-boot settings"""
    if not is_root():
        systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "You need to be run this program as root to repair your settings." + systemd_boot_manager.CLEAR)
        sys.exit(2)
    print(systemd_boot_manager.BLUE + "INITIATING CONFIGURATION REPAIR" + systemd_boot_manager.CLEAR)
    print("-" * 20, "\n")
    # Get UUID
    print(systemd_boot_manager.BLUE + "GETTING APPRORIATE SETTINGS" + systemd_boot_manager.CLEAR)
    UUID = get_UUID(verbose)
    # Get default entry
    default_entry = get_default_boot_entry(verbose)
    # Make them permanent
    print(systemd_boot_manager.BLUE + "WRITING SETTINGS TO DISK" + systemd_boot_manager.CLEAR)
    generate_settings(UUID, default_entry=default_entry, verbose=verbose)
    print("\n")
    check(verbose)


def set_enabled():
    """Set systemd-boot-manager as enabled"""
    with open("/etc/systemd-boot-manager/enabled.conf", "w") as file:
        file.write("enabled")


def set_disabled():
    """Set systemd-boot-manager as disabled"""
    with open("/etc/systemd-boot-manager/enabled.conf", "w") as file:
        file.write("")


def set_as_default_entry(entry):
    """Set 'entry' as the default bootloader entry"""
    if not is_root():
        systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "You need to be run this program as root to repair your settings." + systemd_boot_manager.CLEAR)
        sys.exit(2)
    entries = get_boot_entries()
    for each in entries:
        if entries[each]["id"] == entry:
            if entries[each]["default"] is True:
                systemd_boot_manager.eprint(systemd_boot_manager.BLUE + "Already Default Entry" + systemd_boot_manager.CLEAR)
                sys.exit()
            # Set as default here
            update_defaults_file(entry)
            try:
                subprocess.check_call(["bootctl", "set-default", entry])
            except subprocess.CalledProcessError as err:
                systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "CANNOT SET INTENDED DEFAULT" + systemd_boot_manager.CLEAR)
                systemd_boot_manager.eprint("Error was:")
                systemd_boot_manager.eprint(err.output)
                sys.exit(err.returncode)
            print(systemd_boot_manager.GREEN + "SUCCESS!" + systemd_boot_manager.CLEAR)
            sys.exit()
    systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "ID Not found. Please provide a valid ID. IDs can be found using `update-systemd-boot --list'.")


def get_settings(verbose):
    """Get current settings"""
    conf = {"UUID": None, "DEFAULT_ENTRY": None}
    if _check_default_entry(verbose=verbose):
        conf["DEFAULT_ENTRY"] = get_default_boot_entry(verbose)
    else:
        raise ValueError("Settings corrupted! Repair recommended!")
    if _check_uuid(verbose=verbose):
        conf["UUID"] = get_UUID(verbose)
    else:
        raise ValueError("Settings corrupted! Repair recommended!")
    return conf


def show_settings(verbose):
    """Print current settings"""
    print(systemd_boot_manager.GREEN + "CURRENT SETTINGS" + systemd_boot_manager.CLEAR)
    print("-" * 20, "\n")
    try:
        settings = get_settings(verbose)
    except ValueError:
        print(systemd_boot_manager.RED + "\nERROR: SETTINGS LIKELY CORRUPTED!" + systemd_boot_manager.CLEAR)
        print(systemd_boot_manager.RED + "\nERROR: REPAIR THIS ISSUE USING THE -r FLAG!\n" + systemd_boot_manager.CLEAR)
        sys.exit(2)
    print(systemd_boot_manager.BLUE + "DEFAULT BOOT ENTRY:\t" + systemd_boot_manager.CLEAR + settings["DEFAULT_ENTRY"])
    devices = _get_devices()
    for each in devices:
        if each["partuuid"] == settings["UUID"]:
            print(systemd_boot_manager.BLUE + "ROOT PARTITION:\t\t" + systemd_boot_manager.CLEAR + each["path"])


# get length of argv
ARGC = len(sys.argv)
VERBOSE = False
POINT = 1
if ARGC >= 2:
    # check for verbose flag first
    for each in enumerate(sys.argv):
        if sys.argv[each[0]] in ("-V", "--verbose"):
            VERBOSE = True
            POINT = each[0]
            break
    if POINT == 1 and VERBOSE:
        POINT = 2
    else:
        POINT = 1
    if sys.argv[POINT] in ("-h", "--help"):
        print(HELP)
    elif sys.argv[POINT] in ("-v", "--version"):
        print(VERSION)
    elif sys.argv[POINT] in ("-u", "--update"):
        trigger(VERBOSE)
    elif sys.argv[POINT] in ("-c", "--check"):
        check(VERBOSE)
    elif sys.argv[POINT] in ("-r", "--repair"):
        repair(VERBOSE)
    elif sys.argv[POINT] in ("-s", "--show-settings"):
        show_settings(VERBOSE)
    elif sys.argv[POINT] in ("-l", "--list"):
        entries = get_boot_entries(verbose=VERBOSE)
        print(systemd_boot_manager.BLUE + "BOOT LOADER ENTRIES" + systemd_boot_manager.CLEAR)
        print("-" * 20, "\n")
        for each in entries:
            print("\t-  " + each)
            print("\t\tID: " + entries[each]["id"])
            print("\t\tDefault: " + str(entries[each]["default"]), "\n")
    elif sys.argv[POINT] in ("-d", "--default"):
        if len(sys.argv) < 3:
            systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "No default specified." + systemd_boot_manager.CLEAR)
            sys.exit(2)
        set_as_default_entry(sys.argv[POINT + 1])
    elif sys.argv[POINT] in ("-e", "--enable"):
        if not is_root():
            systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "You need to be run this program as root to enable systemd-boot-manager." + systemd_boot_manager.CLEAR)
            sys.exit(2)
        if not systemd_boot_manager.is_enabled():
            set_enabled()
            print(systemd_boot_manager.SUCCESS + "systemd-boot-manager enabled!" + systemd_boot_manager.CLEAR)
            sys.exit(0)
        else:
            print(systemd_boot_manager.WARNING + "systemd-boot-manager already enabled." + systemd_boot_manager.CLEAR)
            sys.exit(1)
    elif sys.argv[POINT] == "--disable":
        if not is_root():
            systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "You need to be run this program as root to disable systemd-boot-manager." + systemd_boot_manager.CLEAR)
            sys.exit(2)
        if not systemd_boot_manager.is_enabled():
            systemd_boot_manager.eprint(systemd_boot_manager.WARNING + "systemd-boot-manager already disabled." + systemd_boot_manager.CLEAR)
            sys.exit(1)
        else:
            set_disabled()
            print(systemd_boot_manager.SUCCESS + "systemd-boot-manager disabled!" + systemd_boot_manager.CLEAR)
            sys.exit(0)
    else:
        systemd_boot_manager.eprint(systemd_boot_manager.ERROR + "Flag: " + sys.argv[1] + " Not understood.")
        print(HELP)
        sys.exit(1)
else:
    trigger(False)
